<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tarock Log</title>
  <style>
    :root{
      --bg:#0b1220; --card:#111a2e; --muted:#9fb0d0; --text:#eef2ff;
      --line:rgba(255,255,255,.12); --good:#2dd4bf; --bad:#fb7185; --warn:#fbbf24; --btn:#3b82f6;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(180deg, #0b1220 0%, #070b14 100%);
      color:var(--text);
    }
    .wrap{max-width:980px;margin:0 auto;padding:8px;display:grid;gap:8px}
    .card{background:rgba(17,26,46,.92);border:1px solid var(--line);border-radius:14px;padding:10px;overflow:hidden; }
    /* Kompakte Controls oben */
    .grid{display:grid;gap:6px}
    .grid.controls{grid-template-columns: 1.15fr .45fr .70fr}
    
    @media (max-width: 360px){ .grid.controls{grid-template-columns: 1fr;} }

    label{display:block;font-size:11px;color:var(--muted);margin:0 0 4px}
    select,input[type="number"],input[type="text"]{
      width:100%;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.22);
      color:var(--text);
      outline:none;
    }
    
    .names.namesCompact{
      display:flex;
      gap:6px;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      padding:2px 0;
    }

    /* jedes Name-Item (das JS erzeugt) */
    .names.namesCompact > div{
      flex: 0 0 auto;
      min-width: 64px;   /* kleiner = weniger breit */
    }

    /* Label komplett weg (falls es noch existiert) */
    .names.namesCompact label{
      display:none !important;
    }

    /* Input flach + schmal */
    .names.namesCompact input{
      padding:4px 6px;
      font-size:11px;
      border-radius:10px;
    }

    /* ganz kleine Handys */
    @media (max-width: 360px){
      .names.namesCompact > div{ min-width: 40px; }
      .names.namesCompact input{ font-size:10.5px; padding:4px 5px; }
    }
    




    .seg{
      display:flex;
      flex-direction: column;  /* Buttons untereinander */
      gap:4px;
    }
    .seg label.btn{
      padding:7px 0;           /* bleibt kompakt */
    }

    /* Spieler-Auswahl: 5 Spalten auch am Handy */
    .players{display:grid;gap:6px;grid-template-columns: repeat(5, minmax(0, 1fr));}
    .pbox{border:1px solid var(--line);border-radius:12px;padding:6px;background:rgba(0,0,0,.16);min-width:0}
    .pname{display:flex;align-items:center;gap:6px;margin:0 0 6px}
    .dot{display:none}
    .pname strong{font-size:11px;font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    @media (max-width: 600px){
      .players{
        display: flex !important;
        gap: 8px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 4px;
      }

      .pbox{ flex: 0 0 60px; }
      .names.namesCompact > div{
        flex: 0 0 auto;
        min-width: 0;           /* wichtig */
      }

      .names.namesCompact input{
        width: 60px;            /* <- FIX: feste Breite */
        max-width: 96px;
        padding: 4px 6px;
        font-size: 11px;
      }
            

      
      
    }




    /* Gewinner/Verlierer/Ausgesetzt: als G/V/- */

    .seg input{display:none}
    .seg label.btn{
      flex:1 1 0;
      text-align:center;
      padding:7px 0;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--text);
      font-size:0;          /* Text verstecken */
      line-height:1;
      user-select:none;
      cursor:pointer;
    }
    .seg input:checked + label.btn{background:rgba(255,255,255,.10);border-color:rgba(255,255,255,.25)}
    .seg input[data-role="W"]:checked + label.btn{background: rgba(45,212,191,.18); border-color: rgba(45,212,191,.45);}
    .seg input[data-role="L"]:checked + label.btn{background: rgba(251,113,133,.18); border-color: rgba(251,113,133,.45);}
    .seg input[data-role="O"]:checked + label.btn{background: rgba(251,191,36,.16); border-color: rgba(251,191,36,.45);}

    .seg input[data-role="W"] + label.btn::after{content:"G";font-size:12px;font-weight:800}
    .seg input[data-role="L"] + label.btn::after{content:"V";font-size:12px;font-weight:800}
    .seg input[data-role="O"] + label.btn::after{content:"-";font-size:12px;font-weight:900}

    /* Aktionen kompakt */
    .actions{display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .msg{font-size:12px;color:var(--muted);min-height:14px}
    button{
      border:0;border-radius:12px;padding:9px 10px;font-weight:700;cursor:pointer;
      background:var(--btn);color:white;box-shadow:0 10px 22px rgba(59,130,246,.18);font-size:13px;line-height:1;
    }
    button.secondary{background:rgba(255,255,255,.08);box-shadow:none;border:1px solid var(--line)}
    .btnrow{display:flex;gap:6px;flex-wrap:wrap;justify-content:flex-end}

    /* Unnötige Texte ausblenden (falls noch vorhanden) */
    .hint,.pill,.foot{display:none !important}

    /* Tabelle: in Scrollfeld */

    .tableWrap{
      width: 100%;
      max-width: 100%;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      max-height: 46vh;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.14);
    }
    
    
    table{width:100%;border-collapse:separate;border-spacing:0;min-width: 680px;}
    thead th{position:sticky;top:0;background:rgba(17,26,46,.98);z-index:1}
    th,td{padding:8px 8px;border-bottom:1px solid var(--line);border-right:1px solid var(--line);font-size:12px;white-space:nowrap}
    th:last-child,td:last-child{border-right:0}
    tbody tr:last-child td{border-bottom:0}
    td.pos{color:var(--good);font-weight:800}
    td.neg{color:var(--bad);font-weight:800}
    td.zero{color:var(--muted);font-weight:700}

    .trail{
      margin-top:4px;
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    @media (max-width: 600px){    
      th, td{
        padding: 5px 6px;   /* kleiner */
        font-size: 11.5px;  /* kleiner */
        line-height: 1.1;   /* kompakter */
      }

      table{
        min-width: 520px;   /* optional: weniger breit */
      }
    }
    
  </style>
</head>
<body>
<div class="wrap">
<div class="card">
<div class="grid" style="grid-template-columns: 1fr;">
  <!-- Zeile 1: Spiel + Punkte -->
  <div style="display:grid; grid-template-columns: minmax(0,1fr) 92px 78px; gap:6px;">

    <div>
      <label for="game">Spiel</label>
      <select id="game"></select>
    </div>
    
    <div>
      <label for="mulPick">-</label>
      <select id="mulPick">
        <option value="1" selected>-</option>
        <option value="2">Gespritzt</option>
        <option value="4">Retour</option>
        <option value="4">Valat</option>        
      </select>
    </div>
      
    <div>
      <label for="basePoints">Punkte</label>
      <input id="basePoints" type="number" inputmode="numeric" min="0" step="1" value="0" />
    </div>
  </div>

  <!-- Zeile 2: Prämie + Prämienpunkte -->
  <div style="display:grid; grid-template-columns: minmax(0,1fr) 92px 78px; gap:6px;">
    <div>
      <label for="bonusPick">Prämie</label>
            <select id="bonusPick">
              <option value="" selected>+ Prämie wählen…</option>
              <option value="0">— Reset (0) —</option>
              <option value="1">König Ultimo: +1</option>
              <option value="1">Trull: +1</option>
              <option value="1">4 Könige: +1</option>
              <option value="1">Pagat: +1</option>
              <option value="2">Uhu: +2</option>
              <option value="3">Kakadu: +3</option>
                                                      
            </select>
    </div>
    
    <div>
      <label for="bonusMulPick">&nbsp;</label>
      <select id="bonusMulPick">
        <option value="1" selected>-</option>
        <option value="2">Gespritzt</option>
        <option value="4">Retour</option>
      </select>
    </div>
        
    <div>
      <label for="bonus">Prämienpunkte</label>
      <input id="bonus" type="number" inputmode="numeric" min="0" step="1" value="0" />
    </div>
  </div>
  
  <div id="bonusTrail" class="trail"></div>

  <!-- Buttons + Message (unverändert lassen) -->
  <div class="btnrow" style="justify-content: flex-start;">
  
    <button id="log" type="button">Schreiben</button>
    
    <button class="secondary" id="deleteLast" type="button">Zurück</button>
    <button class="secondary" id="clearAll" type="button">Leeren</button>
  </div>

  <div class="msg" id="msg"></div>
</div>
</div>


  <!-- Mitte: Namen + kompakte Gewinner/Verlierer -->
  <div class="card">
    <div class="names namesCompact" id="nameInputs"></div>

    <div class="players" id="players" style="margin-top:8px;"></div>
  </div>

  <!-- Unten: Tabelle (scroll) -->
  <div class="card">
    <div class="tableWrap">
      <table id="table">
        <thead>
        <tr>
          <th>Zeit</th>
          <th id="h0">Spieler 1</th>
          <th id="h1">Spieler 2</th>
          <th id="h2">Spieler 3</th>
          <th id="h3">Spieler 4</th>
          <th id="h4">Spieler 5</th>
          <th>Spiel</th>
          <th>Punkte</th>
          <th>Prämie</th>
        </tr>

        </thead>
        <tbody id="tbody"></tbody>
        <tbody>
        <tr class="sumrow" id="sumrow">
          <td>Summe</td>
          <td id="s0">0</td>
          <td id="s1">0</td>
          <td id="s2">0</td>
          <td id="s3">0</td>
          <td id="s4">0</td>
          <td></td>
          <td></td>
          <td></td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>

<script>
(() => {
  // --- Konfiguration: Spieleliste ---
  const games = [
    { name: "Prämie zum Spiel davor", points: 0 },
    { name: "Trischaken (Vorhand)", points: 1 },
    { name: "Rufer (Vorhand)", points: 1 },
    { name: "Piccolo", points: 2 },
    { name: "Zwiccolo", points: 2 },
    { name: "Triccolo", points: 2 },
    { name: "Quadriccolo", points: 2 },    
    { name: "Solorufer", points: 2 },
    { name: "Pagatrufer", points: 3 },
    { name: "Bettler", points: 4 },
    { name: "Sechserdreier (Vorhand)", points: 4 },
    { name: "Uhurfer", points: 5 },
    { name: "Farbendreier", points: 5 },
    { name: "Dreier", points: 5 },
    { name: "Piccolo ouvert", points: 6 },
    { name: "Zwiccolo ouvert", points: 6 },
    { name: "Kakadurufer", points: 7 },
    { name: "Bettler ouvert", points: 8 },
    { name: "Quapilrufer", points: 9 },
    { name: "Farbensolo", points: 10 },
    { name: "Solodreier", points: 10 },    
  ];


  // --- State ---
  const state = {
    names: ["Spieler 1","Spieler 2","Spieler 3","Spieler 4","Spieler 5"],
    totals: [0,0,0,0,0],
    rounds: [] // {time, game, base, bonus, deltas[5]}
  };
  
  const STORAGE_KEY = "tarockLog_v1";

  function saveState(){
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        names: state.names,
        totals: state.totals,
        rounds: state.rounds
      }));
    }catch(e){ /* ignore */ }
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const data = JSON.parse(raw);
      if (data?.names && data?.totals && data?.rounds){
        state.names = data.names;
        state.totals = data.totals;
        state.rounds = data.rounds;
      }
    }catch(e){ /* ignore */ }
  }
  
  function setBonusTrail(s){
    bonusTrail = s || "";
    if (bonusTrailEl) bonusTrailEl.textContent = bonusTrail;
  }
  function appendBonusTrail(part){
    if (!part) return;
    bonusTrail = bonusTrail ? (bonusTrail + " · " + part) : part;
    if (bonusTrailEl) bonusTrailEl.textContent = bonusTrail;
  }
  
  
  let bonusItems = [];         // [{label, value, factor}]
  let lastBonusIndex = -1;     // Index der zuletzt gewählten Prämie

  function recalcBonus(){
    const total = bonusItems.reduce((sum, it) => sum + (it.value * it.factor), 0);
    bonusInp.value = String(total);

    // Trail: Prämientext + Faktor-Text (Gespritzt/Retour)
    const trail = bonusItems
      .map(it => `${it.label}${it.factorLabel ? " " + it.factorLabel : ""}`)
      .join(" · ");

    setBonusTrail(trail);
  }

  // 7) JS: LETZTE SPIELZEILE LÖSCHEN (füge bei den Actions-Listenern hinzu)
  function deleteLast(){
    const last = state.rounds.pop();
    if (!last){
      setMsg("Keine Zeile zum Löschen.", "warn");
      return;
    }
    // totals zurückrechnen
    for (let i=0;i<5;i++){
      state.totals[i] -= last.deltas[i];
    }
    renderTable();
    setMsg(`Letzte Zeile gelöscht: ${last.game}, Basis ${last.base}, Prämie ${last.bonus}.`, "ok");
  }
  
  function applyMultiplier(){
    const factor = parseInt(mulPick?.value || "1", 10) || 1;
    baseInp.value = String((baseFromGame || 0) * factor);
  }


  
  
  // Names header inputs
  function renderNameInputs(){
    nameInputsEl.innerHTML = "";
    state.names.forEach((n, i) => {
      const wrap = document.createElement("div");
      const lab = document.createElement("label");
      lab.textContent = `Name ${i+1}`;
      lab.style.marginBottom = "6px";
      const inp = document.createElement("input");
      inp.type = "text";
      inp.value = n;
      inp.addEventListener("input", () => {
        state.names[i] = inp.value.trim() || `Spieler ${i+1}`;
        updateHeaders();
        renderPlayers(); // names on boxes
        renderTable();   // reflect header names in existing rows
      });
      wrap.appendChild(lab);
      wrap.appendChild(inp);
      nameInputsEl.appendChild(wrap);
    });
    updateHeaders();
  }

  function updateHeaders(){
    for (let i=0; i<5; i++){
      const th = document.getElementById("h"+i);
      if (th) th.textContent = state.names[i];
    }
  }

  // Players boxes
  function renderPlayers(){
    playersEl.innerHTML = "";
    state.names.forEach((name, idx) => {
      const box = document.createElement("div");
      box.className = "pbox";

      const head = document.createElement("div");
      head.className = "pname";
      const dot = document.createElement("div");
      dot.className = "dot";
      const st = document.createElement("strong");
      st.textContent = name;
      head.appendChild(dot);
      head.appendChild(st);

      const seg = document.createElement("div");
      seg.className = "seg";

      // radio group per player
      const group = "p" + idx;

      const options = [
        { key: "W", label: "Gewinner" },
        { key: "L", label: "Verlierer" },
        { key: "O", label: "Ausgesetzt" }
      ];

      options.forEach((o, j) => {
        const id = `${group}_${o.key}`;
        const r = document.createElement("input");
        r.type = "radio";
        r.name = group;
        r.id = id;
        r.value = o.key;
        r.dataset.role = o.key;

        // Default: Ausgesetzt
        if (o.key === "O") r.checked = true;

        const l = document.createElement("label");
        l.className = "btn";
        l.htmlFor = id;
        l.textContent = o.label;

        seg.appendChild(r);
        seg.appendChild(l);
      });

      box.appendChild(head);
      box.appendChild(seg);
      playersEl.appendChild(box);
    });
  }

  function getRoles(){
    // returns array of "W"|"L"|"O"
    const roles = [];
    for (let i=0;i<5;i++){
      const sel = document.querySelector(`input[name="p${i}"]:checked`);
      roles.push(sel ? sel.value : "O");
    }
    return roles;
  }

  function setMsg(text, kind="info"){
    // kind: info|ok|warn|err
    const color =
      kind==="ok" ? "var(--good)" :
      kind==="warn" ? "var(--warn)" :
      kind==="err" ? "var(--bad)" : "var(--muted)";
    msgEl.style.color = color;
    msgEl.innerHTML = text || "";
  }

  function fmtDelta(x){
    if (x > 0) return `+${x}`;
    return String(x);
  }

  function cellClass(x){
    if (x > 0) return "pos";
    if (x < 0) return "neg";
    return "zero";
  }

  function nowStamp(){
    const d = new Date();
    const pad = (n)=>String(n).padStart(2,"0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }
  

  // --- Punkteverteilung ---
  function computeDeltas(roles, base, bonus){
    const winners = [];
    const losers = [];
    const outs = [];
    roles.forEach((r,i)=>{
      if (r==="W") winners.push(i);
      else if (r==="L") losers.push(i);
      else outs.push(i);
    });

    // Ausgesetzt immer 0
    const deltas = [0,0,0,0,0];

    // valid patterns with 4 active players (outs 1) or 4 active (outs 1) or 4 active (outs 1) or 4 active (outs 1)
    // also allow 2W2L with 1 out, or without out (would require 4 players only -> but we always have 5; still allow 2W2L + 1O)
    // We'll enforce the described cases:
    // 2W/2L (and remaining O), 3W/1L (and remaining O), 3L/1W (and remaining O)
    const w = winners.length, l = losers.length, o = outs.length;

    const tooManyActive = (w + l) > 4 || o < 1; // because with 5 players, these patterns imply exactly 1 out
    // However user didn't explicitly say "immer 1 ausgesetzt". But patterns mention 4 participants.
    // We'll support both: either exactly 1 out OR exactly 0 out with 4 players not possible, so keep rule: allow o>=1 and (w+l)==4
    const activeOk = (w + l) === 4; // ensures 1 out (since 5 total)
    if (!activeOk){
      return { ok:false, reason:`Bitte genau <b>4 aktive Spieler</b> wählen (Gewinner/Verlierer) und <b>1× Ausgesetzt</b>. Aktuell: ${w} Gewinner, ${l} Verlierer, ${o} ausgesetzt.` };
    }

    // Case A: 2W/2L
    if (w===2 && l===2){
      // Gewinner plus (Spiel+Prämie), Verlierer Minus
      winners.forEach(i => deltas[i] = (base + bonus));
      losers.forEach(i => deltas[i] = (-base - bonus));
      outs.forEach(i => deltas[i] = 0);
      return { ok:true, deltas, label:"2W/2L" };
    }

    // Case B: 3W/1L
    if (w===3 && l===1){
      // Gewinner plus, Verlierer 3x Minus
      winners.forEach(i => deltas[i] = (base + bonus));     // Bonus pro Gewinner
      losers.forEach(i => deltas[i] = (-3*(base+bonus)));
      outs.forEach(i => deltas[i] = 0);
      return { ok:true, deltas, label:"3W/1L" };
    }

    // Case C: 3L/1W
    if (w===1 && l===3){
      // Verlierer minus, Gewinner plus
      losers.forEach(i => deltas[i] = (-base-bonus));
      winners.forEach(i => deltas[i] = (3*base + 3*bonus));   // gewinnt gegen 3 Verlierer
      outs.forEach(i => deltas[i] = 0);
      return { ok:true, deltas, label:"3L/1W" };
    }

    return { ok:false, reason:`Ungültige Kombination: ${w} Gewinner, ${l} Verlierer, ${o} ausgesetzt. Erlaubt: 2/2, 3/1, 1/3 (jeweils mit 1× Ausgesetzt).` };
  }

  // --- Rendering Table ---
  function renderTable(){
    tbody.innerHTML = "";
    for (const r of state.rounds){

      const tr = document.createElement("tr");

      // Zeit
      const tdTime = document.createElement("td"); tdTime.textContent = r.time;
      tr.appendChild(tdTime);

      // Spieler 1..5 (Deltas)
      r.deltas.forEach((d)=>{
        const td = document.createElement("td");
        td.textContent = fmtDelta(d);
        td.className = cellClass(d);
        tr.appendChild(td);
      });

      // Spielname / Punkte / Prämie
      const tdGame = document.createElement("td"); tdGame.textContent = r.game;
      const tdBase = document.createElement("td"); tdBase.textContent = r.base;
      const tdBonus = document.createElement("td"); tdBonus.textContent = r.bonus;

      tr.appendChild(tdGame);
      tr.appendChild(tdBase);
      tr.appendChild(tdBonus);


      tbody.appendChild(tr);
    }
    // update sums
    for (let i=0;i<5;i++){
      const el = document.getElementById("s"+i);
      if (!el) continue;
      const v = state.totals[i];
      el.textContent = fmtDelta(v);
      el.className = cellClass(v);
    }
    updateHeaders();
    
    saveState();
  }

  function resetRound(){
    // set all to Ausgesetzt
    for (let i=0;i<5;i++){
      const r = document.getElementById(`p${i}_O`);
      if (r) r.checked = true;
    }
    setMsg("Auswahl zurückgesetzt.");
  }

  function clearAll(){
    state.rounds = [];
    state.totals = [0,0,0,0,0];
    renderTable();
    localStorage.removeItem(STORAGE_KEY); // optional
    setMsg("Alles gelöscht.");
  }
  
  // --- DOM -------------------------------------------------------
  
  const gameSel = document.getElementById("game");
  const baseInp = document.getElementById("basePoints");
  const bonusInp = document.getElementById("bonus");
  const playersEl = document.getElementById("players");
  const nameInputsEl = document.getElementById("nameInputs");
  const msgEl = document.getElementById("msg");
  const tbody = document.getElementById("tbody");
  const deleteLastBtn = document.getElementById("deleteLast");

  const mulPick = document.getElementById("mulPick");
  let baseFromGame = 0; // merkt sich den "originalen" Spielwert ohne Multiplikator

  mulPick?.addEventListener("change", applyMultiplier);

  const bonusPick = document.getElementById("bonusPick");
  const bonusMulPick = document.getElementById("bonusMulPick");
  const bonusTrailEl = document.getElementById("bonusTrail");
  let bonusTrail = "";

  bonusMulPick?.addEventListener("change", () => {
    if (lastBonusIndex < 0 || !bonusItems[lastBonusIndex]) return;

    const factor = parseInt(bonusMulPick.value || "1", 10) || 1;
    const label = bonusMulPick.selectedOptions[0]?.textContent?.trim() || "";

    bonusItems[lastBonusIndex].factor = factor;
    bonusItems[lastBonusIndex].factorLabel = (label && label !== "-") ? label : "";

    recalcBonus();

    // wieder auf "-" zurück (damit Faktor wirklich nur für "die letzte" gilt)
    // bonusMulPick.value = "1";
  });

  bonusPick?.addEventListener("change", () => {
    const v = bonusPick.value;
    if (v === "") return;

    // Reset: alles weg
    if (v === "0") {
      bonusItems = [];
      lastBonusIndex = -1;
      bonusInp.value = "0";
      if (typeof setBonusTrail === "function") setBonusTrail("");
      if (bonusMulPick) bonusMulPick.value = "1"; // Faktor zurück auf "-"
      bonusPick.value = "";
      return;
    }

    // Prämie hinzufügen (zuerst) mit Faktor 1
    const add = parseInt(v, 10) || 0;
    const label = bonusPick.selectedOptions[0]?.textContent?.trim() || String(add);

    bonusItems.push({ label, value: add, factor: 1, factorLabel: "" });

    lastBonusIndex = bonusItems.length - 1;

    recalcBonus();

    // Faktor-Auswahl vorbereiten: auf "-" setzen (User wählt danach x2/x4)
    if (bonusMulPick) bonusMulPick.value = "1";

    // bonusPick.value = "";
  });

  deleteLastBtn?.addEventListener("click", deleteLast);

  // Build game select
  for (const g of games) {
    const opt = document.createElement("option");
    opt.value = g.name;
    opt.textContent = `${g.name} (${g.points} Punkte)`;
    opt.dataset.points = String(g.points);
    gameSel.appendChild(opt);
  }
  
  gameSel.value = games[0].name;
  baseInp.value = String(games[0].points);

  gameSel.addEventListener("change", () => {
    const opt = gameSel.selectedOptions[0];
    baseFromGame = parseInt(opt?.dataset?.points ?? "0", 10) || 0;
    applyMultiplier();
    
    // reset Prämien
    bonusItems = [];
    lastBonusIndex = -1;
    recalcBonus();
    setBonusTrail("");

    bonusMulPick && (bonusMulPick.value = "1");
    bonusPick && (bonusPick.value = "");
    
  });

  // beim Start einmal setzen
  baseFromGame = parseInt(gameSel.selectedOptions[0]?.dataset?.points ?? "0", 10) || 0;
  applyMultiplier();
  

  // --- Actions ---
  document.getElementById("resetRound")?.addEventListener("click", resetRound);
  document.getElementById("clearAll").addEventListener("click", clearAll);

  document.getElementById("log").addEventListener("click", () => {
    // const game = gameSel.value;
    
    const rawTrail =
      (typeof bonusTrail !== "undefined" && bonusTrail)
        ? bonusTrail
        : (bonusTrailEl?.textContent || "");

    // entfernt "+Zahlen" und ":+Zahlen" aus den Trail-Teilen
    const cleanTrail = rawTrail
      .split("·")
      .map(s => s.trim()
        .replace(/\s*:\s*\+\d+\s*/g, " ")  // "Kakadu: +3" -> "Kakadu"
        .replace(/\+\d+/g, "")            // "+1" -> ""
        .replace(/\s{2,}/g, " ")
        .trim()
      )
      .filter(Boolean)
      .join(" · ");

    const game = cleanTrail ? `${gameSel.value} (${cleanTrail})` : gameSel.value;

    
    
    const base = Math.max(0, parseInt(baseInp.value || "0", 10) || 0);
    const bonus = Math.max(0, parseInt(bonusInp.value || "0", 10) || 0);

    const roles = getRoles();
    const res = computeDeltas(roles, base, bonus);

    if (!res.ok){
      setMsg(res.reason, "warn");
      return;
    }

    const time = nowStamp();
    const deltas = res.deltas;

    // apply totals
    for (let i=0;i<5;i++){
      state.totals[i] += deltas[i];
    }

    // store round
    state.rounds.push({ time, game, base, bonus, deltas });

    renderTable();

    setMsg(`Protokolliert (<strong>${res.label}</strong>): ${game}, Basis ${base}, Prämie ${bonus}.`, "ok");
  });

  loadState();

  // Init UI
  renderNameInputs();
  renderPlayers();
  renderTable();
  setMsg("Wähle das Spiel, Prämie, und pro Spieler Gewinner/Verlierer/Ausgesetzt.");

})();
</script>
</body>
</html>
